# 사라지는 숫자 해설 (C)


### 문제 요약
n × m 크기의 2차원 배열에서 매 초마다 숫자가 책읽는 방향으로 하나씩 사라지는 문제

### 핵심 규칙
1. **매 초마다**: 1열부터 m열까지 순서대로 각 열의 맨 위 숫자를 하나씩 제거
2. **0은 빈 칸**: 0은 "없는 것"으로 간주하므로, 0이 아닌 첫 번째 숫자를 찾아 제거
3. **t초 진행**: 총 t개의 숫자가 제거됨 (각 열마다 t개가 아니라 **전체 합쳐서 t개**)

### 입출력 예시
**입력 -> !!숫자들이 공백 없이 입력되는게 문제의 조건임!!**
```
6 3 5
11101
00003
12314
```

**출력:**
```
00000
00003
02304
```

---

## 이 문제를 쉽게 풀게해줄 아이디어 

### 1. "t초동안 진행한다" => "숫자 t개를 제거한다"



### 2. 숫자 제거 후 i(세로 성분)는 무조건 0으로 리셋

### -> 왜 i를 0으로 리셋하는가? 

하나의 논리로 문제를 풀어야 편하기 때문임. <br>
그 논리는 문제 조건 중 하나였던 다음임 ->  **현재 관측한 값이 0이면 i(세로)를 증가시킨다.**<br>

즉, 우리는 t초 동안 1행(가로)만 돈다고 보면 생각이 쉬워짐. 어차피 관측한 값이 0이면 다음 행을 볼거니깐.

예를들어, 내가 지금 두번째 행을 볼 차례일지라도 첫번째 행부터 시작하는 것임.<br> 내가 두번째 행을 보게 되었다는 말은, 적어도 첫번째 행은 무조건 모두 0으로 초기화 되어있을 것이란 말임.
<br>그래서  위 논리로 인해 두번째 행(혹은 그 이상)을 보게 됨.




## 전체 코드 (설명 주석 포함)

```c
#include <stdio.h>

/** 예시 입출력
입력:
6 3 5
11101
00003
12314

출력:
00000
00003
02304
 */
int main()
{
    int t, n, m;
    scanf("%d %d %d", &t, &n, &m);
       
    int grid[n][m];

    /**
     *  "공백 없이 주어진다"는 조건 때문에
     *  %1d를 사용하여 한 글자씩 받을거임 -> (%1d를 이번 기회에 알아두자!)
     */
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            scanf("%1d", &grid[i][j]);

    int removed_count = 0; // 총 제거한 숫자 개수
    int i = 0, j = 0;      // while문 안에서 사용할 인덱스
    /**
     * 숫자를 t개 삭제하면 종료하면 됨
     *
     *  "t초 동안 진행한다" = "숫자를 t개 삭제한다"
     *  라고 인식하면 편함
     */
    while (removed_count < t)
    {
        if (grid[i][j] != 0)
        { // 0이 아니면 삭제 대상임
            grid[i][j] = 0;
          
            // 삭제 이후엔 무조건 i(세로) 값을 0으로
            i = 0;                      
            
            // 삭제했으면 다음 j(가로)로 가야함. 
            //단, j는 순환적이기에 (0->1->2->3->4->0->1...이 되어야해서) 나머지 연산(%) 활용
            j = (j + 1) % m; 

            removed_count++;
        }
        else
        { // 삭제할 숫자를 못찾음 (현재가 0임) -> 다음 세로 값으로 가야함 
            i++;
        }
    }

    // 결과 출력
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            printf("%d", grid[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

---

## 전체 코드 (주석 제거 버전)

```c
#include <stdio.h>
/** 예시 입출력
입력:
6 3 5
11101
00003
12314

출력:
00000
00003
02304
 */
int main()
{
    int t, n, m;
    scanf("%d %d %d", &t, &n, &m);
    
    int grid[n][m];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            scanf("%1d", &grid[i][j]);

    int removed_count = 0;
    int i = 0, j = 0;

    while (removed_count < t)
    {
        if (grid[i][j] != 0)
        {
            grid[i][j] = 0;
            i = 0;
            j = (j + 1) % m;
            removed_count++;
        }
        else
        {
            i++;
        }
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            printf("%d", grid[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

<Br>

## Appendix: 생각해볼만 한 것
**이 코드는 입력되는 2차원 배열의 각 원소들의 값에 따라 에러가 나기도 한다.
<br>
문제 자체에 오류가 있다는 이야기인데, 그게 무엇일까?**
